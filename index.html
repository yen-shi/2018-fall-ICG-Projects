<html>

<head>
<title>ICG WebGL &mdash; HW1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link rel="stylesheet" type="text/css" href="index.css">
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>

<script id="fragmentShader" type="fragment">
    #extension GL_OES_standard_derivatives : enable
    precision mediump float;

    // varyings for vetex and fragment shaders
    varying vec4 fragcolor;
    varying vec3 surfaceWorldPosition;
    varying vec3 normal;
    varying vec3 vSurfaceToView;
    uniform int uShadingModeFrag;

    // uniform vec3 uLights;
    // directional light
    uniform vec3 uDirectionalLight;
    // point light
    varying vec3 vSurfaceToPointLight;
    varying vec3 N, L;
    varying float lambertian, specular, shininessVal;

    void main(void) {
        gl_FragColor = fragcolor;
        vec3 nNormal = normalize(normal);

        vec3 U = dFdx(surfaceWorldPosition);                     
        vec3 V = dFdy(surfaceWorldPosition);                 
        vec3 N1 = normalize(cross(U, V));
        
        // Mode 0: flat shading
        if (uShadingModeFrag == 0)
            nNormal = N1;

        vec3 surfaceToLightDirection = normalize(vSurfaceToPointLight);
        float directionalLight = dot(nNormal, uDirectionalLight);
        float pointLight = dot(nNormal, surfaceToLightDirection);
        float accumulateLight = min(directionalLight + pointLight, 1.0);

        // Mode 1: only light
        if (uShadingModeFrag == 0 || uShadingModeFrag == 3)
            gl_FragColor.rgb *= pointLight;

        float localSpecular = 0.0;
        if(lambertian > 0.0) {
            vec3 R = reflect(-L, nNormal);      // Reflected light vector
            vec3 V = normalize(vSurfaceToView); // Vector to viewer
            // Compute the specular term
            float specAngle = max(dot(R, V), 0.0);
            localSpecular = pow(specAngle, shininessVal);
        }
        if (uShadingModeFrag == 2)
            gl_FragColor = vec4((0.8 * lambertian + localSpecular) * fragcolor.rgb, 1.0);        
    }
</script>

<script id="vertexShader" type="vertex">
    // object attributes
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aFrontColor;
    attribute vec3 aNormal;

    // shading mode
    uniform int uShadingMode;

    // environment attributes
    uniform int uTextureMode;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform sampler2D uSampler;

    // varyings for vetex and fragment shaders
    varying vec4 fragcolor;
    varying vec3 surfaceWorldPosition;
    varying vec3 normal;
    varying vec3 vSurfaceToView;

    // view point
    uniform vec3 uViewPosition;

    // point light
    uniform vec3 uPointLightPosition;
    uniform vec3 uPointLightColor;
    varying vec3 vSurfaceToPointLight;
    varying vec3 N, L;
    varying float lambertian, specular, shininessVal;

    void main(void) {
        surfaceWorldPosition = mat3(uMVMatrix) * aVertexPosition;
        vSurfaceToView = uViewPosition - surfaceWorldPosition;
        vSurfaceToPointLight = uPointLightPosition - surfaceWorldPosition;
        vec3 halfVector = normalize(vSurfaceToPointLight + vSurfaceToView);

        float dist = length(vSurfaceToPointLight);
        float att = (1.0 / (1.0 + (0.00005 * dist * dist)));

        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        normal = mat3(uMVMatrix) * aNormal;

        N = normalize(normal);
        L = normalize(vSurfaceToPointLight);

        lambertian = max(dot(N, L), 0.0);
        shininessVal = 40.0;

        specular = 0.0;
        if(lambertian > 0.0) {
            specular = dot(N, halfVector);
            specular = pow(specular, shininessVal);
        }

        if (uTextureMode != 1) {
            fragcolor = vec4(aFrontColor.rgb, 1.0);
        }
        else {
            vec4 fragmentColor;
            fragmentColor = texture2D(uSampler, vec2(aTextureCoord.s, aTextureCoord.t));
            fragcolor = vec4(fragmentColor.rgb, fragmentColor.a);;
        }

        if (uShadingMode == 1)
            fragcolor = vec4((0.8 * lambertian + specular) * fragcolor.rgb, 1.0);
    }
</script>

<script type="text/javascript">
    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw 'extension not support';
        }
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "fragmentShader");
        var vertexShader = getShader(gl, "vertexShader");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.directionalLight = gl.getUniformLocation(shaderProgram, "uDirectionalLight");
        shaderProgram.pointLight = gl.getUniformLocation(shaderProgram, "uPointLightPosition");
        shaderProgram.pointLightColor = gl.getUniformLocation(shaderProgram, "uPointLightColor");
        shaderProgram.viewPosition = gl.getUniformLocation(shaderProgram, "uViewPosition");

        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.textureMode = gl.getUniformLocation(shaderProgram, "uTextureMode");
        shaderProgram.shadingMode = gl.getUniformLocation(shaderProgram, "uShadingMode");
        shaderProgram.shadingModeFrag = gl.getUniformLocation(shaderProgram, "uShadingModeFrag");
    }

    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();
    var dirLightPosition = [-5, 8, 8];
    var pointLightPosition = [60, 60, 60];
    var viewPosition = [60, 60, 60];
    var textureMode = 0, shadingMode = 0;

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        gl.uniform3fv(shaderProgram.directionalLight, m4.normalize(dirLightPosition));
        gl.uniform3fv(shaderProgram.pointLight, pointLightPosition);
        gl.uniform3fv(shaderProgram.pointLightColor, m4.normalize([0.6, 0.9, 0.9]));
        gl.uniform3fv(shaderProgram.viewPosition, viewPosition);
        gl.uniform1i(shaderProgram.textureMode, textureMode);
        gl.uniform1i(shaderProgram.shadingMode, shadingMode);
        gl.uniform1i(shaderProgram.shadingModeFrag, shadingMode);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    class Model3D {
        constructor() {
            this.vertexPositionBuffer = gl.createBuffer();
            this.vertexNormalBuffer = gl.createBuffer();
            this.vertexFrontColorBuffer = gl.createBuffer();
            this.vertexBackColorBuffer = gl.createBuffer();
        }
    }

    var filenames = ["Csie.json", "Teapot.json", "Plant.json"];
    var objects = {}
    var objTransform = {
        // Scale, Rotation, Position
        "Csie.json": [
            [1, 1, 1],
            [-90, 0, 0],
            [-0.58, -0.32, -0.47]
        ],
        "Teapot.json": [
            [5, 5, 5],
            [-90, 0, 0],
            [0.81, 0.2, -1.04]
        ],
        "Plant.json": [
            [1, 1, 1],
            [-90, 0, 0],
            [1.18, -0.53, -0.47]
        ]
    }

    function setPositions() {
        filenames.forEach((filename) => {
            if (filename in objects) {
                let curMatrix = objects[filename].matrix;
                mat4.identity(curMatrix);
                // mat4.translate(curMatrix, objTransform[filename][0]);
                mat4.scale(curMatrix, objTransform[filename][0]);
                mat4.rotateX(curMatrix, degToRad(objTransform[filename][1][0]));
                mat4.rotateY(curMatrix, degToRad(objTransform[filename][1][1]));
                mat4.rotateZ(curMatrix, degToRad(objTransform[filename][1][2]));
                mat4.translate(curMatrix, objTransform[filename][2]);
            }
        });
    }

    function handleLoadedObject(data) {
        let object = new Model3D();
        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexNormals), gl.STATIC_DRAW);
        object.vertexNormalBuffer.itemSize = 3;
        object.vertexNormalBuffer.numItems = data.vertexNormals.length / 3;

        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexFrontColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexFrontcolors), gl.STATIC_DRAW);
        object.vertexFrontColorBuffer.itemSize = 3;
        object.vertexFrontColorBuffer.numItems = data.vertexFrontcolors.length / 3;

        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexBackColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexBackcolors), gl.STATIC_DRAW);
        object.vertexBackColorBuffer.itemSize = 3;
        object.vertexBackColorBuffer.numItems = data.vertexBackcolors.length / 3;

        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexPositions), gl.STATIC_DRAW);
        object.vertexPositionBuffer.itemSize = 3;
        object.vertexPositionBuffer.numItems = data.vertexPositions.length / 3;
        return object;
    }

    // Check for the various File API support.
    // if (window.File && window.FileReader && window.FileList && window.Blob)
    //     console.log("Great success! All the File APIs are supported.");
    // else
    //     alert("the file apis are not fully supported in this browser.");

    // let reader = new FileReader();
    // reader.onload = (function(theFile) {
    //     return function(e) {
    //         console.log("Read file ", escape(theFile.name), " done");
    //         var lines = e.target.result.split(
    //             /[\r\n]+/g);  // tolerate both Windows and Unix linebreaks
    //         console.log("READ", lines[0]);
    //     };
    // })(filename);

    // reader.readAsText(filename);

    function loadObject(filename) {
        var request = new XMLHttpRequest();
        request.open("GET", filename);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                let obj = handleLoadedObject(JSON.parse(request.responseText));
                obj.matrix = mat4.create();
                objects[filename] = obj
            }
        }
        request.overrideMimeType("application/json");
        request.send();
    }

    function loadObjects() {
        let tmpMatrix = mat4.create();
        filenames.forEach((filename) => { loadObject(filename); });
    }

    var teapotVertexPositionBuffer;
    var teapotVertexNormalBuffer;
    var teapotVertexTextureCoordBuffer;
    var teapotVertexIndexBuffer;

    function handleLoadedTeapot(teapotData) {
        teapotVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
        teapotVertexNormalBuffer.itemSize = 3;
        teapotVertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

        teapotVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexTextureCoords), gl.STATIC_DRAW);
        teapotVertexTextureCoordBuffer.itemSize = 2;
        teapotVertexTextureCoordBuffer.numItems = teapotData.vertexTextureCoords.length / 2;

        teapotVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
        teapotVertexPositionBuffer.itemSize = 3;
        teapotVertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

        teapotVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(teapotData.indices), gl.STATIC_DRAW);
        teapotVertexIndexBuffer.itemSize = 1;
        teapotVertexIndexBuffer.numItems = teapotData.indices.length;
    }

    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    var galvanizedTexture;

    function initTextures() {
        galvanizedTexture = gl.createTexture();
        galvanizedTexture.image = new Image();
        galvanizedTexture.image.onload = function () {
            handleLoadedTexture(galvanizedTexture)
        }
        galvanizedTexture.image.src = "galvanizedTexture.jpg";
        galvanizedTexture.image.src = "red.jpg";
    }

    var teapotTransform = [
        [1, 1, 1],
        [0, -90, 0],
        [0, 0, 0]
    ]

    function loadTeapot() {
        var request = new XMLHttpRequest();
        request.open("GET", "Teapot_Origin.json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedTeapot(JSON.parse(request.responseText));
            }
        }
        request.overrideMimeType("application/json");
        request.send();
    }

    // Compute a matrix for the camera
    var cameraMatrix = mat4.create();
    var teapotAngle = 0;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(cameraMatrix);
        // mat4.rotateY(cameraMatrix, degToRad(teapotAngle));
        mat4.translate(cameraMatrix, [0, 0, 50]);
        mat4.inverse(cameraMatrix, cameraMatrix);
        mat4.multiply(pMatrix, cameraMatrix, pMatrix);

        setPositions();
        textureMode = 0;
        shaderProgram.vertexFrontColorAttribute = gl.getAttribLocation(shaderProgram, "aFrontColor");
        gl.enableVertexAttribArray(shaderProgram.vertexFrontColorAttribute);
        filenames.forEach((filename) => {
            if (filename in objects) {
                let obj = objects[filename];
                mat4.set(obj.matrix, mvMatrix);
                setMatrixUniforms();

                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, obj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertexFrontColorBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexFrontColorAttribute, obj.vertexFrontColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, obj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, obj.vertexPositionBuffer.numItems);

            }
        });
        gl.disableVertexAttribArray(shaderProgram.vertexFrontColorAttribute);

        if (teapotVertexPositionBuffer == null || teapotVertexNormalBuffer == null || teapotVertexTextureCoordBuffer == null || teapotVertexIndexBuffer == null) {
            return;
        }

        mat4.identity(mvMatrix);
        mat4.scale(mvMatrix, teapotTransform[0]);
        mat4.rotateX(mvMatrix, degToRad(teapotTransform[1][0]));
        mat4.rotateY(mvMatrix, degToRad(teapotTransform[1][1]));
        mat4.rotateZ(mvMatrix, degToRad(teapotTransform[1][2]));
        mat4.translate(mvMatrix, teapotTransform[2]);
        
        textureMode = 1;
        setMatrixUniforms();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        gl.uniform1i(shaderProgram.samplerUniform, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, teapotVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, teapotVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, teapotVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
        gl.drawElements(gl.TRIANGLES, teapotVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

        gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
    }

    var lastTime = 0;
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
            teapotAngle += 0.03 * elapsed;
        }
        lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
    }

    function webGLStart() {
        var canvas = document.getElementById("ICG-canvas");
        initGL(canvas);
        initShaders();
        loadObjects();

        initTextures();
        loadTeapot();

        gl.clearColor(0.0, 0.2, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="ICG-canvas" style="border: none;" width="800" height="600">
    </canvas>
    <div id="uiContainer">
        <div id="ui">
        </div>
    </div>
</body>

<script type="text/javascript">
    function createElementFromHTML(htmlString) {
        var div = document.createElement('div');
        div.innerHTML = htmlString.trim();

        // Change this to div.childNodes to support multiple top-level nodes
        return div.firstChild;
    }

    updateObjectValues = (name, type, typeIdx, idx) => (event, ui) => {
        objTransform[name][typeIdx][idx] = ui.value;
        drawScene();
    };

    let valueScales = {
        "Scale": [0.1, 10, 0.01, 2],
        "Rotation": [-180, 180, 1, 0],
        "Position": [-100, 100, 0.1, 2],
    }

    let uiList = document.getElementById("ui");
    filenames.forEach((filename) => {
        ["Scale", "Rotation", "Position"].forEach((type, typeIdx) => {
            ["X", "Y", "Z"].forEach((axis, idx) => {
                let objId = filename.slice(0, -5) + type + axis;
                uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
                webglLessonsUI.setupSlider("#" + objId,
                    { value: objTransform[filename][typeIdx][idx],
                      slide: updateObjectValues(filename, type, typeIdx, idx),
                      min: valueScales[type][0],
                      max: valueScales[type][1],
                      step: valueScales[type][2],
                      precision: valueScales[type][3] });
    });});});

    updateTeapotValues = (type, typeIdx, idx) => (event, ui) => {
        teapotTransform[typeIdx][idx] = ui.value;
        drawScene();
    };

    ["Scale", "Rotation", "Position"].forEach((type, typeIdx) => {
        ["X", "Y", "Z"].forEach((axis, idx) => {
            let objId = "BigTeapot" + type + axis;
            uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
            webglLessonsUI.setupSlider("#" + objId,
                { value: teapotTransform[typeIdx][idx],
                    slide: updateTeapotValues(type, typeIdx, idx),
                    min: valueScales[type][0],
                    max: valueScales[type][1],
                    step: valueScales[type][2],
                    precision: valueScales[type][3] });
    });});

    updateDirectionalLight = (idx) => (event, ui) => {
        dirLightPosition[idx] = ui.value;
        drawScene();
    };

    ["X", "Y", "Z"].forEach((axis, idx) => {
        let type = "Position";
        let objId = "DirectionalLight" + type + axis;
        uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
        webglLessonsUI.setupSlider("#" + objId,
            { value: dirLightPosition[idx],
                slide: updateDirectionalLight(idx),
                min: valueScales[type][0],
                max: valueScales[type][1],
                step: valueScales[type][2],
                precision: valueScales[type][3] });
            });

    updatePointLight = (idx) => (event, ui) => {
        pointLightPosition[idx] = ui.value;
        drawScene();
    };

    ["X", "Y", "Z"].forEach((axis, idx) => {
        let type = "Position";
        let objId = "PointLight" + type + axis;
        uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
        webglLessonsUI.setupSlider("#" + objId,
            { value: pointLightPosition[idx],
                slide: updatePointLight(idx),
                min: valueScales[type][0],
                max: valueScales[type][1],
                step: valueScales[type][2],
                precision: valueScales[type][3] });
            });

    updateShadingMode = (event, ui) => {
        shadingMode = ui.value;
        drawScene();
    };

    {
        let objId = "ShadingMode";
        uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
        webglLessonsUI.setupSlider("#" + objId,
            { value: shadingMode,
              slide: updateShadingMode,
              min: 0,
              max: 3,
              step: 1,
              precision: 0 });
    };
</script>

</html>
