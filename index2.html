<html>

<head>
<title>ICG WebGL &mdash; HW1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link rel="stylesheet" type="text/css" href="index.css">
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>

<script id="fragmentShader" type="fragment">
    precision mediump float;

    // varyings for vetex and fragment shaders
    varying vec4 fragcolor;
    varying vec3 normal;
    // varying vec4 vertexViewSpace;

    // directional light
    uniform vec3 uDirectionalLight;
    // point light
    // varying vec3 vSurfaceToPointLight;

    void main(void) {
        vec3 nNormal = normalize(normal);
        float light = dot(nNormal, uDirectionalLight);
        gl_FragColor = fragcolor;
        gl_FragColor.rgb *= light;
    }
</script>

<script id="vertexShader" type="vertex">
    // object attributes
    attribute vec3 aVertexPosition;
    attribute vec3 aFrontColor;
    attribute vec3 aNormal;

    // environment attributes
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    // varyings for vetex and fragment shaders
    varying vec4 fragcolor;
    varying vec3 normal;
    // varying vec4 vertexViewSpace;

    // point light
    // uniform vec3 uPointLightPosition;
    // varying vec3 vSurfaceToPointLight;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        fragcolor = vec4(aFrontColor.rgb, 1.0);;
        normal = aNormal;
    }
</script>

<script type="text/javascript">
    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "fragmentShader");
        var vertexShader = getShader(gl, "vertexShader");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexFrontColorAttribute = gl.getAttribLocation(shaderProgram, "aFrontColor");
        gl.enableVertexAttribArray(shaderProgram.vertexFrontColorAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.directionalLight = gl.getUniformLocation(shaderProgram, "uDirectionalLight");
    }

    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();
    var dirLightPosition = [-0.5, -0.5, 1];

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        gl.uniform3fv(shaderProgram.directionalLight, m4.normalize(dirLightPosition));
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    class Model3D {
        constructor() {
            this.vertexPositionBuffer = gl.createBuffer();
            this.vertexNormalBuffer = gl.createBuffer();
            this.vertexFrontColorBuffer = gl.createBuffer();
            this.vertexBackColorBuffer = gl.createBuffer();
        }
    }

    var filenames = ["Csie.json", "Teapot.json", "Plant.json"];
    var objects = {}
    var objTransform = {
        // Scale, Rotation, Position
        "Csie.json": [
            [1, 1, 1],
            [-90, 0, 0],
            [-0.58, -0.32, -0.47]
        ],
        "Teapot.json": [
            [5, 5, 5],
            [-90, 0, 0],
            [0.81, 0.2, -1.04]
        ],
        "Plant.json": [
            [1, 1, 1],
            [-90, 0, 0],
            [1.18, -0.53, -0.47]
        ]
    }

    function setPositions() {
        filenames.forEach((filename) => {
            if (filename in objects) {
                let curMatrix = objects[filename].matrix;
                mat4.identity(curMatrix);
                // mat4.translate(curMatrix, objTransform[filename][0]);
                mat4.scale(curMatrix, objTransform[filename][0]);
                mat4.rotateX(curMatrix, degToRad(objTransform[filename][1][0]));
                mat4.rotateY(curMatrix, degToRad(objTransform[filename][1][1]));
                mat4.rotateZ(curMatrix, degToRad(objTransform[filename][1][2]));
                mat4.translate(curMatrix, objTransform[filename][2]);
            }
        });
    }

    function handleLoadedObject(data) {
        let object = new Model3D();
        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexNormals), gl.STATIC_DRAW);
        object.vertexNormalBuffer.itemSize = 3;
        object.vertexNormalBuffer.numItems = data.vertexNormals.length / 3;

        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexFrontColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexFrontcolors), gl.STATIC_DRAW);
        object.vertexFrontColorBuffer.itemSize = 3;
        object.vertexFrontColorBuffer.numItems = data.vertexFrontcolors.length / 3;

        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexBackColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexBackcolors), gl.STATIC_DRAW);
        object.vertexBackColorBuffer.itemSize = 3;
        object.vertexBackColorBuffer.numItems = data.vertexBackcolors.length / 3;

        gl.bindBuffer(gl.ARRAY_BUFFER, object.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vertexPositions), gl.STATIC_DRAW);
        object.vertexPositionBuffer.itemSize = 3;
        object.vertexPositionBuffer.numItems = data.vertexPositions.length / 3;
        return object;
    }

    // Check for the various File API support.
    // if (window.File && window.FileReader && window.FileList && window.Blob)
    //     console.log("Great success! All the File APIs are supported.");
    // else
    //     alert("the file apis are not fully supported in this browser.");

    // let reader = new FileReader();
    // reader.onload = (function(theFile) {
    //     return function(e) {
    //         console.log("Read file ", escape(theFile.name), " done");
    //         var lines = e.target.result.split(
    //             /[\r\n]+/g);  // tolerate both Windows and Unix linebreaks
    //         console.log("READ", lines[0]);
    //     };
    // })(filename);

    // reader.readAsText(filename);

    function loadObject(filename) {
        var request = new XMLHttpRequest();
        request.open("GET", filename);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                let obj = handleLoadedObject(JSON.parse(request.responseText));
                obj.matrix = mat4.create();
                objects[filename] = obj
            }
        }
        request.overrideMimeType("application/json");
        request.send();
    }

    function loadObjects() {
        let tmpMatrix = mat4.create();
        filenames.forEach((filename) => { loadObject(filename); });
    }

    // Compute a matrix for the camera
    var cameraMatrix = mat4.create();
    var teapotAngle = 0;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 10.0, pMatrix);

        mat4.identity(cameraMatrix);
        mat4.rotateY(cameraMatrix, degToRad(teapotAngle));
        mat4.translate(cameraMatrix, [0, 0, 3]);
        mat4.inverse(cameraMatrix, cameraMatrix);
        mat4.multiply(pMatrix, cameraMatrix, pMatrix);

        setPositions();
        filenames.forEach((filename) => {
            if (filename in objects) {
                let obj = objects[filename];
                mat4.set(obj.matrix, mvMatrix);
                setMatrixUniforms();
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, obj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertexFrontColorBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexFrontColorAttribute, obj.vertexFrontColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, obj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, obj.vertexPositionBuffer.numItems);
            }
        });
    }

    var lastTime = 0;
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
            teapotAngle += 0.03 * elapsed;
        }
        lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
    }

    function webGLStart() {
        var canvas = document.getElementById("ICG-canvas");
        initGL(canvas);
        initShaders();
        loadObjects();

        gl.clearColor(0.0, 0.2, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }

</script>

</head>

<body onload="webGLStart();">
    <canvas id="ICG-canvas" style="border: none;" width="800" height="600">
    </canvas>
    <div id="uiContainer">
        <div id="ui">
        </div>
    </div>
</body>

<script type="text/javascript">
    function createElementFromHTML(htmlString) {
        var div = document.createElement('div');
        div.innerHTML = htmlString.trim();

        // Change this to div.childNodes to support multiple top-level nodes
        return div.firstChild;
    }

    updateObjectValues = (name, type, typeIdx, idx) => (event, ui) => {
        objTransform[name][typeIdx][idx] = ui.value;
        drawScene();
    };

    updateDirectionalLight = (idx) => (event, ui) => {
        dirLightPosition[idx] = ui.value;
        drawScene();
    };

    let valueScales = {
        "Scale": [0.1, 10, 0.01, 2],
        "Rotation": [-180, 180, 1, 0],
        "Position": [-10, 10, 0.01, 2],
    }

    let uiList = document.getElementById("ui");
    filenames.forEach((filename) => {
        ["Scale", "Rotation", "Position"].forEach((type, typeIdx) => {
            ["X", "Y", "Z"].forEach((axis, idx) => {
                let objId = filename.slice(0, -5) + type + axis;
                uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
                webglLessonsUI.setupSlider("#" + objId,
                    { value: objTransform[filename][typeIdx][idx],
                      slide: updateObjectValues(filename, type, typeIdx, idx),
                      min: valueScales[type][0],
                      max: valueScales[type][1],
                      step: valueScales[type][2],
                      precision: valueScales[type][3] });
    });});});
    ["X", "Y", "Z"].forEach((axis, idx) => {
        let type = "Position";
        let objId = "DirectionalLight" + type + axis;
        uiList.appendChild(createElementFromHTML(`<div id="${ objId }"></div>`));
        webglLessonsUI.setupSlider("#" + objId,
            { value: dirLightPosition[idx],
                slide: updateDirectionalLight(idx),
                min: valueScales[type][0],
                max: valueScales[type][1],
                step: valueScales[type][2],
                precision: valueScales[type][3] });
            });
</script>

</html>
